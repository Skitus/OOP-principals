/*
    Abstraction is the process of hiding the complexity of the implementation and highlighting 
    only those aspects of the object that are important in this context. In programming, abstraction allows 
    the developer to focus on the interface of interaction with the object, and not on the details of its
    internal implementation. This facilitates the understanding of the program, its development and testing, and also promotes code reuse.
    In the context of OOP, abstraction can be implemented using abstract classes and interfaces.


    Using the abstract keyword for a method in an abstract class requires that each subclass provide
     its own implementation of this method. By removing abstract, you must provide the implementation 
    of the method directly in the abstract class, making this method an ordinary, inheritable method
    with predefined behavior that can be overridden in subclasses. The choice between these two approaches
    depends on your design and whether you want to force subclasses to provide their own method implementation
    or provide them with a base implementation.

    Declaring a method signature is a way to define the interface of a function or method without specifying the implementation itself.
    The method signature includes the method name, a list of parameters (their types and order) and the return type.


    The Liskov Substitution Principle (LSP) is one of the five principles of SOLID, the fundamental principles of object-oriented design and programming. LSP was formulated by Barbara Liskov in 1987 in her conference paper and further developed in various publications. The principle states:

    Objects in a program should be replaceable by instances of their subtypes without changing the correctness of the program.

    In other words, if class S is a subclass of class T, then objects of type T in a program can be replaced by objects of type S (where S has behavior compatible with that of T) without changing the desired properties of the program (correctness, task completion, etc.). This means that subclasses must not violate the behavior and expectations that are valid for the base class.

    Examples of LSP applications
    Base Class Contract Compliance: A subclass must comply with the contract established by the base class. This means that the methods of the subclass must produce results within the expectations that are set for the base class methods.

    Immutability of preconditions: A subclass must not enforce the preconditions (that is, conditions that must be true before a method can be executed) of the base class.

    Non-weakening of postconditions: A subclass must not weaken the postconditions (that is, conditions that are guaranteed to be true after the method is executed) of the base class.

    Invariants: All invariants present in the base class must be preserved by the subclass.

    Exceptions: Subclasses should not introduce new exceptions that cannot be generated by the base class, unless such behavior is expected by the client of the class.

    Importance of LSP
    The Liskov Substitution Principle emphasizes the importance of designing classes and their
    hierarchies in such a way that one class can be freely replaced by another class that is a subtype of it, 
    without affecting the performance of the program. Adhering to LSP helps ensure code modularity, simplifies 
    code testing, and increases flexibility when developing and implementing changes. It is aimed at preventing 
    situations when using a subclass instead of its base class leads to errors due to inappropriate behavior of the subclass.
*/

interface IMovable {
  move(): void;
}

abstract class NewVehicle implements IMovable {
  constructor(protected readonly numberOfWheels: number) {}

  abstract move(): void;

  displayNumberOfWheels(): void {
    console.log(`This vehicle has ${this.numberOfWheels} wheels.`);
  }
}

class NewCar extends NewVehicle {
  constructor() {
    super(4);
  }

  move(): void {
    console.log("The car is moving.");
  }
}

// Example of abstractions and pholymorphyism
class Vehicle1 {
  start(): void {
    console.log("Vehicle started");
  }
}

class Car1 implements Vehicle1 {
  start(): void {
    console.log("Car started");
  }
}
